<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RUST NUGGETS</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Display.html"><strong aria-hidden="true">1.</strong> Display</a></li><li class="chapter-item expanded "><a href="Error_handling_notes.html"><strong aria-hidden="true">2.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="file_handling.html"><strong aria-hidden="true">3.</strong> File Handling</a></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">4.</strong> Performance</a></li><li class="chapter-item expanded "><a href="writing_libraries.html"><strong aria-hidden="true">5.</strong> Writing Libraries and APIs</a></li><li class="chapter-item expanded "><a href="dark_magic.html"><strong aria-hidden="true">6.</strong> Dark Magic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_rust_runtime.html"><strong aria-hidden="true">6.1.</strong> The Rust Runtime</a></li></ol></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">7.</strong> Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RUST NUGGETS</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>These are just short notes, you are better off reading from the official Rust API documentation.<br />
Especially the std::fmt module OR core::fmt</p>
<p>(&quot;this is a {} format string {}&quot;, these, are, format, arguments );</p>
<p><strong>core::fmt::Arguments</strong> is a struct that represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.</p>
<p>The <strong>format_args! macro</strong> produces an Argument after consuming (format_string and format_arguments)</p>
<p>The <strong>core::fmt::Formatter</strong> is a struct that contains configuration on how to format text. It acts as a builder pattern for the string that will get eventually pushed to the underlying buffer.</p>
<p>The Formatter is not a global or singleton formatter that applies to all values universally in your program; Each time you call the fmt function within a Debug or Display implementation, you get a new instance of Formatter.</p>
<p>Each Formatter is attached to an anonymous buffer. A buffer is something that implements the Write Trait that has been discussed below. The Formatter has the Write trait defined, making it a buffer by its own right... so the earlier sentence about it haveing a buffer attached to it was wrong --- IT IS THE BUFFER ITSELF</p>
<p><strong>Trait Write</strong> - This is the trait that a buffer needs to implement. This trait requires you to define how a string fits into your buffer structure. There are 2 kinds of write traits; <strong>core::fmt::Write</strong> and <strong>Trait core::io::Write</strong>. If you want to make that buffer flushable use the io::write, else use the fmt::write trait.</p>
<p><strong>The write function</strong> - the write function takes in a Buffer + a precompiled string (Argument). It then puts that precompiled string into the Buffer as specified by the Buffer's Write Trait implementation.</p>
<p><strong>The write macro</strong> - the write macro takes in a Buffer + format string + arguments. It then dumps that format_string and arguments into the buffer as specified by the Write Trait functions.</p>
<p><strong>The writeln macro</strong> - self explanatory</p>
<p>The Display implementation :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl fmt::Display for SuperError {
    // the Formatter builder struct implements the Write trait
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;SuperError is here!&quot;)
    }
}   
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>These are my notes on error_handling written for quick reference, You will be better off reading about error_handling from the official Rust API documentation.</p>
<ul>
<li>
<p><strong>Panic Runtime</strong> - a set of instructions that are part of Rust's ABI implementation. They are a subset of the main Rust runime that deal specifically with handling panics. This set of instructions takes care of the following (I am guessing) </p>
<ul>
<li>Halting the current thread</li>
<li>Managing a part of the thread's runtime stack</li>
<li>Unwinding or discarding the thread's stack</li>
</ul>
</li>
<li>
<p><strong>Hook</strong> - A hook is typically a set of instructions that gets immediately called when an event happens. When a panic() function gets called, a default hook gets called even before the panic runtime is invoked. The default hook prints a message to standard error and generates a backtrace if requested. In a no_std environment where there is no standard error, you will want to define your own hook.</p>
</li>
</ul>
<p>You can however submit your own custom hook using the set_hook() function even is a std setup.</p>
<p>If you want to check the name of the current hook in use, use the 'take_hook' function. However, the take_hook function Unregisters the current panic hook and returns it, registering the default hook in its place. If the default hook is registered it will be returned, but remain registered.</p>
<p><strong>panic! and panic_any</strong> are macros that are used to initiate a panic. The payload is a datastructure that gets returned by the panic() function. Panic(&amp;str) always takes a string payload. panic_any returns custom datastuctures apart from the string payload. </p>
<p><strong>PanicInfo</strong> - A struct providing information about a panic.<br />
PanicInfo structure is passed to a panic hook set by the set_hook function.</p>
<p><strong>The Error Trait</strong> 
The error trait can be defined on any type that already implements the Debug + Display trait.<br />
The functions that automatically get provided by the Error trait are 4, only one is relevant... the rest are deprecated or usable in nightly-only.</p>
<p>The relevant function is source(). 
You have hardcode your souorces across different modules.<br />
Check out this exampple :</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error; // use the Error Trait
use std::fmt::{Display, Formatter, write}; // use the Display trait. For an item to be able to implement the Error trait, it must first implement both Debug &amp; Display traits


#[derive(Debug)]
struct LowerError{  }

impl Display for LowerError{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), std::fmt::Error&gt; { 
        write!(f, &quot;I am LowerError&quot;)
    }
}

impl Error for LowerError{}


#[derive(Debug)]
struct HigherError {
    source : LowerError, // hardcoded source, I do not know if the Error::source function requires this field to be hardcoded
                         // I do not know if this field can take another name... I do not kow if I can leave it out and still call the source() and get a Some(Err) 
}

impl Display for HigherError {
    fn fmt (&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), std::fmt::Error&gt;{
        write(f, format_args!(&quot;I am HigherError&quot;))
    }
}

impl Error for HigherError{
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.source)
    }
}


fn get_higher_error() -&gt; HigherError{
    HigherError { source: LowerError{} }
}



fn main(){

    let e = get_higher_error();

    println!(&quot;e = {}&quot;, e);
    println!(&quot;e source = {:?}&quot;, e.source());
    println!(&quot;e source error = {}&quot;, e.source().unwrap());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-handling-in-rust"><a class="header" href="#file-handling-in-rust">File Handling in Rust</a></h1>
<p>Reference --&gt;  std::fs documentation</p>
<p>Directory's components can be represented as an Iterator full of (File/Folder) abstractions called DirEntry</p>
<h2 id="dealing-with-directories"><a class="header" href="#dealing-with-directories">Dealing with Directories</a></h2>
<p>The Entries of a Directory/Folder are stored in an Iterator called ReadDir. 
The elements inside the ReadDir can either be entries to files or sub-folders. These elements/entries are abstracted by a special struct called : DirEntry</p>
<pre><code>## DirEntry
- A DirEntry is an Abstraction of  File or a Subdirectory within a Parent Folder.   
- You can decompose a DirEntry to a path using the fun : pub fn path(&amp;self) -&gt; PathBuf
- You can get the metadata of that file/Folder : pub fn metadata(&amp;self) -&gt; Result&lt;Metadata&gt;
  - metadata contains info about : FileType(file, folder, symlink), length, last_modified, last accessed, permissions
</code></pre>
<p>To populate the ReadDir Iterator, </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<p>Assumption is that the required functionalities have been met.<br />
performance metrics :</p>
<ol>
<li>Code Execution speed</li>
<li>memory usage</li>
<li>Development time (compilation, collaboration, deployment )</li>
</ol>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<p>This is the act of analysing the current performance metrics of the program. ie Analysing it and giving the current perfomance results.<br />
Some performance profiling results include :</p>
<ol>
<li>Execution Time</li>
<li>Resource Usage results (CPU, power, Memory, Network bandwidth)</li>
<li>Number of requests (eg database queries)</li>
<li>Function-level analysis results eg Which funtions get called more?, at which frequency? which function uses more resources? Which function calls are unnecessary in certain flows? Which functions can be ommited safely?</li>
<li>Compilation time</li>
</ol>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<p><a href="https://nnethercote.github.io/perf-book/benchmarking.html">source</a></p>
<p>This is the act of : </p>
<ol>
<li>Profiling programs that do the same thing (or close to the same thing)</li>
<li>Comparing the profiling results (ie. benchmarking)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>When building a library, you do not pass data structures with editable/accessible data... 
- you pass functions
- functions bundled as traits
- A struct that only exposes functions ... not data. users should never have to know how data is organized within a struct... their code should never change because you changed some data structures</p>
<p>Point being : expose fuctions ONLY if possible. But never pass an editable/accessible <strong>data</strong> structure</p>
<p>Validate all data coming in. For example, if you are writing a gui library that consumes a html file, make sure the html file is of the right format.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<ul>
<li>Return Results that have the same Mother &lt;Ok, Err&lt;my_library::mod_1_error&gt;&gt;</li>
<li>Make the error impl the Error trait</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dark-magic"><a class="header" href="#dark-magic">Dark Magic</a></h1>
<p>There are concepts in Rust that are so elusive to me. This are things that no matter how much I read about them, my head doesn't get a thing.</p>
<ol>
<li>Lang items in Rust : <a href="https://manishearth.github.io/blog/2017/01/11/rust-tidbits-what-is-a-lang-item/?ref=ductile.systems">source</a></li>
<li>The Rust Runtime. I have an idea what it entails. But I do not have a full picture</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rust-runtime"><a class="header" href="#the-rust-runtime">The Rust Runtime</a></h1>
<p>References :</p>
<ol>
<li><a href="https://ductile.systems/rusts-runtime/">Blog by Michael Gattozzi</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>https://dhghomon.github.io/easy_rust/Chapter_1.html</li>
</ul>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<ol>
<li><a href="https://nnethercote.github.io/perf-book/benchmarking.html">The Rust Performance Book</a></li>
<li><a href="https://nnethercote.github.io/">Blogs by Nicholas Nethercote</a></li>
<li>https://github.com/bheisler/criterion.rs </li>
</ol>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<ol>
<li><a href="https://proptest-rs.github.io/proptest/intro.html">Proptest</a></li>
</ol>
<h2 id="package-management"><a class="header" href="#package-management">Package Management</a></h2>
<ol>
<li>Cargo and the Cargo Book</li>
</ol>
<h2 id="better-code"><a class="header" href="#better-code">Better Code</a></h2>
<ol>
<li><a href="https://doc.rust-lang.org/clippy/">Clippy</a></li>
</ol>
<h2 id="web"><a class="header" href="#web">Web</a></h2>
<ol>
<li>Trunk</li>
<li>Leptos</li>
<li>Egui</li>
</ol>
<h2 id="ui"><a class="header" href="#ui">UI</a></h2>
<ol>
<li>Leptos</li>
<li>Egui</li>
</ol>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<ol>
<li>The book from the Past : Design Patterns Elements of Reusable Object-Oriented Software Produced by KevinZhang (2016)</li>
<li>The Rust Book : https://rust-unofficial.github.io/patterns/</li>
<li>Refactoring Guru Book</li>
<li>Rust Design Patterns Brenden Matthews (2002)</li>
</ol>
<h2 id="miscellenious"><a class="header" href="#miscellenious">Miscellenious</a></h2>
<ol>
<li>Serde - serializing and deserializing structs</li>
<li></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
